
### **Important Notice**

whenever you make a change, you need to update this file and README.md so that later next ai agent knows what the newest version is

# Reader Codebase Instructions

## Project Overview
A lightweight EPUB-to-Markdown converter system with static HTML reading interface. Two independent components:
1. **EPUB Converter** (`epub_to_md_gui.py`) - Python GUI tool with auto-dependency installation
2. **Web Reader** (HTML/JS/CSS) - Client-side web app with localStorage progress tracking

## Architecture & Data Flow




### Component Interaction
```
EPUB Files → epub_to_md_gui.py → books_src/{book_id}/
                    ↓
              meta.json (chapters metadata)
              *.md files (chapter content)
              assets/ (images)
                    ↓
           books.json (registry)
                    ↓
        Web Reader (index.html)
             ↓        ↓
        book.html  chapter.html
```

### Data Structures

**books.json** - Array of book entries (root, auto-updated by converter):
- `book_id`: Slug format (lowercase, hyphens), used for URLs & localStorage
- `title`, `author`, `description`: Display metadata
- `meta_path`: Path to `books_src/{book_id}/meta.json`
- New books are automatically added at the beginning of the array

**meta.json** - Per-book metadata (auto-generated, per book):
- `book_id`, `title`, `author`
- `chapters[]`: Array with `chapter_id`, `order`, `title`, `markdown_file`

**Chapter Files** - Naming: `{order:02d}-{book_slug}--{chapter_slug}.md`
- Example: `09-popular--chapter-1.md`
- Auto-generated by converter, referenced in meta.json

**localStorage Keys** - All prefixed for scope:
- `reading_progress::{book_id}::{chapter_id}` → `{scrollY, timestamp}`
- `last_opened_chapter::{book_id}` → `{chapter_id, timestamp}`
- `font_scale` → Integer (20-200), default 100
- `selection_toolbar_enabled` → Boolean string ('true'/'false'), default 'true'

## Critical Developer Workflows

### Adding a New Book

1. Run `python epub_to_md_gui.py`
2. Select EPUB file(s) - tool auto-extracts title/author from OPF metadata
3. Converter generates: `books_src/{book_id}/meta.json`, `*.md`, `assets/`
4. Converter automatically updates `books.json` with new entry at the beginning
5. Reload web reader to see new book

**Debugging failed conversions**:
- Check console output for specific error (OPF parsing, missing manifest items, etc.)
- Verify EPUB structure: `unzip -l file.epub` should show `META-INF/container.xml` and `.opf` file
- If chapter extraction is incomplete, check if `<spine>` items have valid `<manifest>` entries
- If images are missing, verify `.epub` contains image files and `extract_assets()` finds them

### Testing the Reader
```bash
# Start local server (required for fetch operations)
python -m http.server 8000
# Open http://localhost:8000
```

**Testing checklist**:
- Load book from `index.html` → verify meta.json fetches correctly
- Navigate chapters → check URL params and sidebar highlighting
- Scroll chapter → verify position saves every 500ms via DevTools localStorage inspector
- Refresh page → scroll should restore to saved position
- Close/reopen browser → "Continue Reading" should resume from last chapter

### Page Navigation Pattern
- **index.html**: Loads `books.json`, renders book grid, passes `book_id` param
- **book.html**: Queries `book_id`, loads corresponding `meta.json`, renders TOC
- **chapter.html**: Queries `book_id` + `chapter_id`, loads `meta.json`, then fetches `*.md`

All navigation via URL query params: `?book_id=X&chapter_id=Y`

## Project-Specific Patterns

### Slug Generation (Python)
```python
def slugify(text: str, max_length: int = None) -> str:
    text = text.lower()
    text = re.sub(r'[^\w\s-]', '', text)
    text = re.sub(r'[-\s]+', '-', text)
    text = text.strip('-')
    
    if max_length and len(text) > max_length:
        text = text[:max_length].rstrip('-') + '...'
    
    return text
```

**Length Limits** (to prevent filesystem issues):
- Book folder name (book_id): Max 50 characters
- Chapter slug: Max 10 characters  
- Author slug: Max 10 characters (if used)
- Total filename: Max 150 characters (format: `{order:02d}-{book_slug}--{chapter_slug}.md`)
- Truncated slugs are cut off at max length and trailing dashes removed

Used for: book_id (from title), chapter_id (from chapter heading)

### EPUB Metadata Extraction (Python)
- Navigate ZIP: `META-INF/container.xml` → OPF path
- Parse OPF with namespaces:
  - `http://purl.org/dc/elements/1.1/` for Dublin Core metadata
  - `http://www.idpf.org/2007/opf` for spine/manifest
- Extract title, author, description from XML elements
- **Chapter extraction**: Read spine items in order, extract HTML content from manifest items
- **Title extraction from HTML**: Try `h1-h6` tags first, fallback to `<title>` tag
- **Image path rewriting**: Markdown image syntax `![alt](path)` → `![alt](assets/filename)`
  - Images extracted to `{book_id}/assets/` directory
  - Supported formats: `.jpg`, `.jpeg`, `.png`, `.gif`, `.svg`, `.webp`
- **Duplicate chapter slug handling**: If chapter slug repeats, append `-{count}` to differentiate

### Web Reader Progress Tracking
- Scroll position saved every 500ms during reading (debounced in `chapter.html` via `setupScrollTracking()`)
- **localStorage schema** (defined in `reader.js`):
  - `reading_progress::{book_id}::{chapter_id}` → `{scrollY, timestamp}` (scroll position per chapter)
  - `last_opened_chapter::{book_id}` → `{chapter_id, timestamp}` (resume reading from last visited chapter)
- **reader.js** utility functions (all pure, no side effects):
  - `saveScrollPosition(bookId, chapterId, scrollY)` - Store scroll Y position
  - `getScrollPosition(bookId, chapterId)` - Retrieve saved position object
  - `restoreScrollPosition(bookId, chapterId)` - Smooth scroll to saved Y (100ms delay for DOM render)
  - `saveLastOpenedChapter(bookId, chapterId)` - Update resume point
  - `getLastOpenedChapter(bookId)` - Get last chapter or null
  - `clearBookProgress(bookId)` - Wipes all keys matching `reading_progress::{book_id}::*` and `last_opened_chapter::{book_id}`
- Progress persists across browser sessions/tabs via localStorage
- **Integration points**: 
  - `index.html` checks `last_opened_chapter` for "Continue Reading" button
  - `book.html` displays resume link if progress exists
  - `chapter.html` calls `restoreScrollPosition()` after Markdown render, `setupScrollTracking()` on scroll

### Responsive Design (chapter.html + styles.css)
**Desktop (>768px)**:
- `.reader-container` uses `display: flex` with sidebar (300px width) + content (flex: 1)
- Sidebar sticky, positioned `top: 60px` (nav bar height), `height: calc(100vh - 60px)`
- `.sidebar-toggle-mobile` hidden (`display: none`)
- `.chapter-content` wide with padding, max-width ~900px centered in content area
- `.chapter-nav` horizontal flex (`justify-content: space-between`)

**Mobile (≤768px)**:
- Sidebar becomes `position: fixed` with `transform: translateX(-100%)` (hidden by default)
- `.sidebar.active` shows sidebar via `transform: translateX(0)` (JavaScript toggle)
- `.sidebar-toggle-mobile` visible (circular FAB, `position: fixed, bottom: 20px, right: 20px`)
- `.content` padding reduced to 20px, font sizes shrink (1em vs 1.1em)
- `.chapter-nav` switches to `flex-direction: column` (buttons stack vertically)
- `.book-title-main` shrinks to 1.8em

**Interactive behavior**:
- `#sidebar-toggle-mobile` button click toggles `.active` class on sidebar
- `#toggle-sidebar` (close button in sidebar header) toggles `.collapsed` class for animation
- Sidebar TOC items get `.active` class matching current `chapter_id` (set in `renderSidebarTOC()`)

### Markdown Rendering
- Uses `marked.js` CDN (`https://cdn.jsdelivr.net/npm/marked/marked.min.js`)
- Called in `chapter.html`: `marked.parse(mdText)` → HTML
- Images in markdown expect relative paths: `assets/image.png`

### Mobile Text Selection Toolbar
**Feature Overview**: Custom text selection toolbar for mobile devices (phones/tablets) with three actions:
1. **Select All** - Selects entire chapter content
2. **Copy** - Copies selected text to clipboard with visual feedback
3. **Dictionary Lookup** - Opens Eudic dictionary app via URL scheme/Intent

**Device Detection** (in `chapter.html`):
- Checks User-Agent for mobile patterns: `/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i`
- Also checks `navigator.maxTouchPoints > 2` for touch-capable devices
- Toolbar only appears on mobile devices when enabled

**Toolbar Behavior**:
- **Show**: Appears above selected text after 100ms debounce on `selectionchange` event
- **Position**: Centered above selection, falls back to below if insufficient space above
- **Hide**: On scroll, clicking outside, or after successful action
- **Positioning**: Absolute positioning with `scrollX`/`scrollY` offsets, viewport boundary checks

**Button Implementations**:
- **Select All**: Creates range covering entire `#chapter-content`, repositions toolbar after selection
- **Copy**: Uses `navigator.clipboard.writeText()`, shows checkmark icon for 1 second on success
- **Dictionary**: 
  - **Android**: Tries Intent scheme first (`intent://peek#Intent;...`), fallback to URL scheme (`eudic://peek/{word}`)
  - **iOS**: Uses URL scheme `eudic://dict/{word}`
  - **Desktop**: Shows alert (feature unavailable)
  - Requires Eudic Dictionary app installed on device

**Settings Integration**:
- Toggle in settings modal: "Enable Text Selection Toolbar" (default: ON)
- Saved to `localStorage.selection_toolbar_enabled`
- Loading state: Reads from localStorage on page load, checks checkbox accordingly
- Apply on confirm: Saves state when user clicks confirm button in settings

**Eudic Dictionary API Integration**:
- **Android Intent** (preferred for popup/LightPeek):
  ```
  intent://peek#Intent;
  action=colordict.intent.action.SEARCH;
  category=android.intent.category.DEFAULT;
  type=text/plain;
  component=com.eusoft.eudic/com.eusoft.dict.activity.dict.LightpeekActivity;
  scheme=eudic;
  S.EXTRA_QUERY={word};
  end
  ```
- **URL Scheme fallback**: `eudic://peek/{word}` (Android), `eudic://dict/{word}` (iOS)
- Words are URL-encoded via `encodeURIComponent()`

**CSS Styling** (in `styles.css`):
- `.selection-toolbar`: White background, rounded corners, shadow, fade-in animation
- `.toolbar-btn`: 44x44px touch targets, SVG icons, hover effects (purple background)
- `.settings-checkbox`: Custom checkbox styling with accent color
- Responsive: Button sizes reduce to 42x42px on mobile (<768px)

## Integration Points

### EPUB Converter Dependencies
- `html2text` - Converts HTML to Markdown (auto-installed via pip)
- `xml.etree.ElementTree` - Parses EPUB OPF files (stdlib)
- Standard library: `zipfile`, `json`, `pathlib`, `re`, `shutil`
- Tkinter for GUI (stdlib)

### Web Reader External Dependencies
- `marked.js` CDN for Markdown → HTML conversion
- Native browser APIs: `fetch`, `localStorage`, `localStorage`, `URL` parsing
- No backend required - fully static/client-side

## Key Files Reference

| File | Purpose | When to Edit |
|------|---------|--------------|
| `epub_to_md_gui.py` | EPUB extraction & conversion logic | Adding EPUB features, changing slug format |
| `books.json` | Book registry | Manually after converter completes |
| `index.html` | Bookshelf UI | Styling, book card layout |
| `reader/book.html` | TOC page | Chapter listing, styles |
| `reader/chapter.html` | Reading interface | Content rendering, progress tracking |
| `reader/reader.js` | Progress utilities | localStorage schema, helper functions |
| `reader/styles.css` | All styling | Responsive design, themes |
| `books_src/{id}/meta.json` | Per-book chapters metadata | Auto-generated; edit if manual corrections needed |

**New Features (Latest Version)**:
- **Mobile Text Selection Toolbar**: Appears on mobile devices when text is selected in `chapter.html`
- **Settings Panel**: Font size adjustment (20%-200%) and toolbar toggle in settings modal
- **Eudic Dictionary Integration**: Direct lookup via URL scheme/Intent for selected text

## Common Pitfalls & Solutions

### EPUB Conversion Issues
- **No chapters extracted**: Spine items may not have valid manifest entries. Check OPF file structure.
- **Image URLs broken**: Ensure regex in `html_to_markdown()` correctly extracts filename from `<img src="...">`.
  - Current pattern: `![alt](old_path)` → `![alt](assets/basename)` 
  - Works for relative paths; absolute paths may need adjustment
- **Duplicate chapter slugs**: System auto-appends `-2`, `-3` to duplicates in `chapter_slugs_used` dict

### Web Reader Issues
- **Fetch fails (CORS)**: Always use local HTTP server (`python -m http.server 8000`), not `file://`
- **localStorage not persisting**: Check browser privacy mode (doesn't persist storage)
- **Sidebar stuck off-screen on mobile**: Verify `.sidebar.active { transform: translateX(0) }` and toggle logic in `chapter.html` script
- **Scroll position not restoring**: 100ms delay in `restoreScrollPosition()` waits for markdown render; increase if DOM heavy

### Data Flow Validation
- **book_id mismatch**: Ensure `books.json` entry `book_id` matches folder name in `books_src/`
- **chapter_id mismatch**: Must match format `{order:02d}-{slug}` from meta.json
- **Broken markdown_file reference**: Verify filename exists in book directory and matches meta.json path exactly

## Common Implementation Tasks

### Adding a New Book Field to Metadata

1. **Converter side** (`epub_to_md_gui.py`):
   - In `extract_epub_metadata()`: Add extraction logic (e.g., parse OPF `<dc:date>` → `publication_date`)
   - In `convert_epub()` return dict: Add field to the book entry dict before returning
   - In `meta.json` creation: Add field to `meta` dict before writing

2. **Registry side** (`books.json`):
   - Add field to existing book entries (manual edit)

3. **UI side** (`index.html`, `book.html`, etc.):
   - Access field via `book.new_field` in JavaScript
   - Add HTML element to display (e.g., `<span class="book-date">${book.publication_date}</span>`)
   - Style in `reader/styles.css`

### Modifying Styles or Layout

- **Sidebar width**: Change `.sidebar { width: 300px }` in `styles.css`
- **Content max-width**: Modify `.content { max-width: 900px }` or `.chapter-content`
- **Color scheme**: Update CSS variables or direct color values (primary `#667eea`, accent `#48bb78`)
- **Mobile breakpoint**: Change `@media (max-width: 768px)` threshold
- **Font sizes**: Adjust `font-size` in `.chapter-content` and heading selectors

### Adding Navigation Features

1. **Chapter filters** (by heading level, search):
   - Parse `currentMeta.chapters` before rendering sidebar
   - Filter array and rebuild TOC in `renderSidebarTOC()`

2. **Table of contents (H1/H2 within chapter)**:
   - After `marked.parse()`, extract headings from generated HTML via regex or DOM parsing
   - Build mini-TOC list and prepend to `#chapter-content`

3. **Keyboard shortcuts** (next/prev chapter):
   - Add `document.addEventListener('keydown', (e) => { if (e.key === 'ArrowRight') { ... } })`
   - Navigate via link click or direct URL change

### Changing Chapter File Organization

1. **Rename file format** (e.g., `{book_slug}/{chapter_id}.md` instead of `{order:02d}-{book_slug}--{chapter_slug}.md`):
   - Update `filename` generation in `convert_epub()` method
   - Update path construction in `chapter.html` when loading markdown
   - Update stored `markdown_file` in `meta.json` accordingly

2. **Move assets to separate folder structure**:
   - Change `extract_assets()` to create `assets/{chapter_id}/` subdirectories
   - Update image path rewriting in `html_to_markdown()` accordingly
   - Adjust relative paths in `chapter.html` fetch calls

### Extending Progress Tracking

1. **Add bookmark functionality**:
   - Create `bookmarks::{book_id}` key storing array of `{chapter_id, scrollY, timestamp, note}`
   - Add functions `addBookmark()`, `getBookmarks()`, `deleteBookmark()` in `reader.js`
   - Show bookmark list in sidebar or as floating panel

2. **Statistics** (reading time, chapters per session):
   - Store in `session::{book_id}::{date}` → `{chapters_read, total_time}`
   - Aggregate daily/weekly stats on bookshelf or book detail page

3. **Export progress**:
   - Serialize all `reading_progress::*` keys to JSON
   - Download as `.json` or sync to server (requires backend)


### **Important Notice**

whenever you make a change, you need to update this file and README.md so that later next ai agent knows what the newest version is